trigger:
- none

pool:
  vmImage: 'windows-latest'

variables:
  - group: Orchestration
  - name: apiPipelinePath
    value: 'API/API-Deployment.yml'
  - name: uiPipelinePath
    value: 'UI/UI-Deployment.yml'
  - name: serviceconnection
    value: 'Dotnet'
  - name: APIWebapp
    value: 'Apitestres'
  - name: UIWebapp
    value: 'testres'

stages:

- stage: CustomerExtraction
  displayName: 'Determine the customer'  
  jobs:
    - job: ExtractCustomer
      displayName: 'Get customer spec'
      steps:
        - checkout: self
          persistCredentials: true
          fetchDepth: 0

        - task: PowerShell@2
          name: CustomerName
          displayName: 'Extarct customer and check change type'
          inputs:
            targetType: 'inline'
            script: |
              Write-Host "Starting script..."
              Write-Host "Organisation: $env:Organisation"
              

              $pat = $env:PAT
              $organization = $env:Organisation
              $repositoryId = $env:repositoryId
              $token = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$pat"))
              $headers = @{ Authorization = "Basic $token"  }

              $Baseuri = "https://dev.azure.com/$organization/"
              $targetBranch = "refs/heads/develop"
              $uri = "${Baseuri}_apis/git/repositories/$repositoryId/pullrequests?searchCriteria.status=completed&searchCriteria.targetRefName=$([uri]::EscapeDataString($targetBranch))&api-version=6.1-preview&`$top=100"
              $response = Invoke-RestMethod -Uri $uri -Method Get -Headers $headers

              if ($response.count -eq 0) {
                Write-Host "No completed PRs found."
                exit 1
              } 
              $latestPR = $response.value | Sort-Object closedDate -Descending | Select-Object -First 1
              $prId = $latestPR.pullRequestId
              $title = $latestPR.title
              $description = $latestPR.description
              $PrRaisedTo = $latestPR.targetRefName
              $labelUri = "${Baseuri}_apis/git/repositories/$repositoryId/pullRequests/$prId/labels?api-version=7.1"
              $labelResponse = Invoke-RestMethod -Uri $labelUri -Method Get -Headers $headers
              if (-not $labelResponse.value -or $labelResponse.value.Count -eq 0) {
                Write-Error "No labels (tags) found on the PR. Expected a tag like GBI_3.9.0"
                exit 1
              }
              $tag = $labelResponse.value[0].name
              Write-Host "Found tag: $tag"
              Write-Host "##vso[task.setvariable variable=tag;isOutput=true]$tag"
              $regex = '^GBIW_\d+\.\d+$'
              $m = [regex]::Match($tag, $regex)
              if (-not $m.Success) {
                  Write-Error "Tag '$tag' does not match the expected format (e.g., GBIW_3.9 or GBIW_3.3.0.5)."
                  exit 1
              }
              

              Write-Host "Valid tag format: $tag"
              Write-Host "Change Type : $changeType , Config: $buildConfiguration,PR title: $title, PR Description: $description,PR raised to: $PrRaisedTo, Tag Mentioned: $tag  "
              
               # Get all branch refs and determine highest version branch
              $uri_branch = "${Baseuri}_apis/git/repositories/$repositoryId/refs?filter=heads/&api-version=6.1-preview.1"
              $response_branch = Invoke-RestMethod -Uri $uri_branch -Method Get -Headers $headers
              
              if (-not $response_branch.value -or $response_branch.count -eq 0) {
                Write-Error "No branches found."
                exit 0
              }
              
              $regex_branch = '^refs/heads/release/GBIW(\d+)\.(\d+)$'
              $versionBranches = @()
              
              foreach ($branch in $response_branch.value) {
              $branchName = $branch.name
                $match = [regex]::Match($branchName, $regex_branch)
                if ($match.Success) {
                  $major = [int]$match.Groups[1].Value
                  $minor = [int]$match.Groups[2].Value
                  $versionBranches += [PSCustomObject]@{
                    BranchName = $branchName
                    Major = $major
                    Minor = $minor
                  }
                }
              }
              
              if ($versionBranches.Count -eq 0) {
                Write-Host "No branches matching the pattern 'GBIW_X.Y' found."
              }
              
              $highestBranch = $versionBranches | Sort-Object -Property @{Expression='Major';Descending=$true}, @{Expression='Minor';Descending=$true} | Select-Object -First 1
              
              Write-Host "Highest branch found: $($highestBranch.BranchName)"
              Write-Host "Major: $($highestBranch.Major), Minor: $($highestBranch.Minor)"
              $branchShortName = $highestBranch.BranchName -replace '^refs/heads/', ''
              Write-Host "##vso[task.setvariable variable=highestBranch;isOutput=true]$branchShortName"
              
             
              $url = 'https://feeds.dev.azure.com/StarkNet01/Project%20ForgePoint/_apis/packaging/Feeds/Kent/Packages/476a8c24-5db1-445a-bcaf-9120a9639a03/versions?api-version=6.0-preview.1'
              $PackageInfo = (Invoke-RestMethod -Uri $url -Method Get -UseDefaultCredential -Headers $headers) 
              $LatestVersion= $PackageInfo.value.version | Select-Object -first 1
              Write-Host "Latest package Version =Â $LatestVersion"
              Write-Host "##vso[task.setvariable variable=LatestVersion;isOutput=true]$LatestVersion"

          env:
            PAT: $(PAT)
            Organisation: $(Organisation)
            repositoryId: $(repositoryId)
        
# Stage: Build and Publish to Azure Artifacts
- stage: BuildAPI
  displayName: 'Build API'
  dependsOn: CustomerExtraction
  condition: succeeded()
  variables:
    tag: $[stageDependencies.CustomerExtraction.ExtractCustomer.outputs['CustomerName.tag']]
    existingbranch: $[stageDependencies.CustomerExtraction.ExtractCustomer.outputs['CustomerName.highestBranch']]
    latest_artifact: $[stageDependencies.CustomerExtraction.ExtractCustomer.outputs['CustomerName.LatestVersion']]
  jobs:
  - job: Build
    displayName: 'Build and Package'
    pool:
      vmImage: 'windows-latest'
    steps:
    - task: PowerShell@2
      name: SetEnvVars
      displayName: 'Set up environment variables'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "tag :$(tag)"
          Write-Host "existingbranch :$(existingbranch)"
          Write-Host "latest_artifact :$(latest_artifact)"
          Write-Host "##vso[task.setvariable variable=tag;isOutput=true]$(tag)"
          Write-Host "##vso[task.setvariable variable=existingbranch;isOutput=true]$(existingbranch)"
          Write-Host "##vso[task.setvariable variable=latest_artifact;isOutput=true]$(latest_artifact)"
    - task: NuGetToolInstaller@1

    - task: NuGetCommand@2
      inputs:
        restoreSolution: '**/ASP.NET_Core_API.sln'

    - task: VSBuild@1
      inputs:
        solution: '**/ASP.NET_Core_API.sln'
        msbuildArgs: '/p:DeployOnBuild=true'
        platform: 'Any CPU'
        configuration: 'Release'

    - task: DotNetCoreCLI@2
      displayName: 'Publish ASP.NET Core API'
      inputs:
        command: 'publish'
        publishWebProjects: false
        projects: 'API/ASP.net_core_API/*.csproj'
        arguments: '--configuration Release --output $(Build.ArtifactStagingDirectory)'
        zipAfterPublish: false

    - task: UniversalPackages@0
      displayName: 'Publish Universal Package to Azure Artifacts'
      condition: and(ne(variables.tag, variables.existingbranch), ne(variables.existingbranch, ''))
      inputs:
        command: 'publish'
        publishDirectory: '$(Build.ArtifactStagingDirectory)'
        feedsToUsePublish: 'internal'
        vstsFeedPublish: 'c70a2f22-0e6a-457d-a56f-4f6733761244/464ac2eb-4d82-46d9-8069-c43b9594ead2'
        vstsFeedPackagePublish: 'workbench'
        versionOption: 'major'

- stage: DeployAPI
  displayName: 'Deploy API'
  dependsOn: BuildAPI
  condition: succeeded()
  variables:
    tag: $[stageDependencies.BuildAPI.Build.outputs['SetEnvVars.tag']]
    existingbranch: $[stageDependencies.BuildAPI.Build.outputs['SetEnvVars.existingbranch']]
    latest_artifact: $[stageDependencies.BuildAPI.Build.outputs['SetEnvVars.latest_artifact']]
  jobs:
  - job: Deploy
    displayName: 'Deploy and Package'

    steps:
    - task: PowerShell@2
      name: SetEnvVars
      displayName: 'Set up environment variables'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "tag :$(tag)"
          Write-Host "existingbranch :$(existingbranch)"
          Write-Host "latest_artifact :$(latest_artifact)"
          Write-Host "##vso[task.setvariable variable=tag;isOutput=true]$(tag)"
          Write-Host "##vso[task.setvariable variable=existingbranch;isOutput=true]$(existingbranch)"
          Write-Host "##vso[task.setvariable variable=latest_artifact;isOutput=true]$(latest_artifact)"
    - task: UniversalPackages@0
      displayName: 'Download Universal Package'
      inputs:
        command: 'download'
        downloadDirectory: '$(System.ArtifactsDirectory)/api'
        feedsToUse: 'internal'
        vstsFeed: 'c70a2f22-0e6a-457d-a56f-4f6733761244/464ac2eb-4d82-46d9-8069-c43b9594ead2'
        vstsFeedPackage: '476a8c24-5db1-445a-bcaf-9120a9639a03'
        vstsPackageVersion: '$(latest_artifact)'

    - task: ArchiveFiles@2
      inputs:
        rootFolderOrFile: '$(System.ArtifactsDirectory)/api'
        includeRootFolder: false
        archiveType: 'zip'
        archiveFile: '$(System.ArtifactsDirectory)/api.zip'
        replaceExistingArchive: true

    - task: AzureRmWebAppDeployment@5
      displayName: 'Deploy to Azure Web App'
      inputs:
        ConnectionType: 'AzureRM'
        azureSubscription: '$(serviceconnection)'
        appType: 'webApp'
        WebAppName: '$(APIWebapp)'
        packageForLinux: '$(System.ArtifactsDirectory)/api.zip'

- stage: ReleaseVersioning
  displayName: 'Create Release Branch'
  dependsOn: DeployAPI
  variables:
    tag: $[stageDependencies.DeployAPI.Deploy.outputs['SetEnvVars.tag']]
    existingbranch: $[stageDependencies.DeployAPI.Deploy.outputs['SetEnvVars.existingbranch']]
    latest_artifact: $[stageDependencies.DeployAPI.Deploy.outputs['SetEnvVars.latest_artifact']]
  condition: succeeded()
  jobs:
  - deployment: CreateRelease
    displayName: 'Create Release Branch'
    environment: 'Staging'   
    strategy:
      runOnce:
        deploy:
          steps:
            - checkout: self
              persistCredentials: true
              fetchDepth: 0
            - task: PowerShell@2
              inputs:
                targetType: 'inline'
                script: |
                  Write-Host "tag :$(tag)"
                  Write-Host "existingbranch :$(existingbranch)"
                  Write-Host "latest_artifact :$(latest_artifact)"

            - task: PowerShell@2
              displayName: 'Check/Create release/$TAG from develop'
              inputs:
                targetType: 'inline'
                script: |
                  $ErrorActionPreference = "Stop"

                  if (-not $env:TAG) {
                    Write-Error "TAG variable is not set. Make sure it is exported from the previous step."
                    exit 1
                  }

                  git config user.email "build@dev.azure.com"
                  git config user.name  "Azure Pipelines"

                  git fetch origin --prune

                  $branchName = "release/$env:TAG"
                  $exists = git ls-remote --heads origin $branchName

                  if (-not $exists) {
                    Write-Host "Release branch $branchName does not exist. Creating from origin/develop..."
                    git checkout -b $branchName origin/develop
                    git push -u origin $branchName
                  } else {
                    Write-Host "Release branch $branchName already exists."
                  }
              env:
                TAG: $(tag)
            - task: PowerShell@2
              displayName: 'Merge develop into existing release branch'
              inputs:
                targetType: 'inline'
                script: |
                  $ErrorActionPreference = "Stop"

                  $tag = $env:TAG
                  if (-not $tag) {
                    Write-Error "TAG variable is not set. Make sure it is defined in the pipeline."
                    exit 1
                  }

                  git config user.email "build@dev.azure.com"
                  git config user.name  "Azure Pipelines"

                  git fetch origin --prune

                  $releaseBranch = "release/$tag"

                  # Check if the release branch exists remotely
                  $branchExists = git ls-remote --heads origin $releaseBranch
                  if (-not $branchExists) {
                    Write-Host "Release branch $releaseBranch does not exist. Skipping merge."
                    exit 0
                  }

                  Write-Host "Merging develop into $releaseBranch"

                  git checkout develop
                  git pull origin develop

                  git checkout -B $releaseBranch origin/$releaseBranch

                  try {
                    git merge --no-ff --no-edit origin/develop
                  } catch {
                    Write-Error "Merge conflict occurred while merging develop into $releaseBranch. Resolve manually."
                    exit 1
                  }

                  git push origin $releaseBranch
              env:
                TAG: $(tag)


