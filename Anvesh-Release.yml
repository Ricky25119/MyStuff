trigger: none

variables:
  - group: Orchestration

parameters:
  - name: Customer
    displayName: Select Customer 
    type: string
    default: 'Test'
    values:
      - Kent
      - CustomerZero
      - CAM
      - GM
      - NARP(NCR)
      - Banes
      - TVS
      - Staffs(OHC)
      - Test

  - name: ArtifactVersion
    displayName: Provide the artifact version
    type: string
    default: 'latest'

  - name: ServiceConnections
    displayName: Select Serviceconnection
    type: string
    default: 'Dotnet'
    values:
      - CareCentric-Workbench
      - S0
      - S1
      - S2
      - S3
      - Dotnet

  - name: Tag
    type: string
    default: 'refs/heads/main'

resources:
  repositories:
  - repository: commonTemplates
    type: git
    name: Project ForgePoint/ASPNET_Application
    ref: 'refs/heads/release/${{ parameters.Tag }}'


stages:

- stage: Build
  displayName: 'Build & Deploy'

  jobs:
  - job: DetectBranch
    displayName: 'Detect Highest release Branch'
    pool:
      vmImage: 'windows-latest'
    steps:


    - checkout: commonTemplates


    - task: PowerShell@2
      name: detect
      displayName: 'Detect release/GBIW Branch'
      inputs:
        targetType: 'inline'
        script: |

          $pat = $env:PAT
          $organization = $env:Organisation
          $repositoryId = $env:repositoryId
          $project = $env:project
          $token = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$pat"))
          $headers = @{ Authorization = "Basic $token"  }
          $url = "https://dev.azure.com/$organization/$project/_apis/git/repositories/$repositoryId/refs?filter=heads/&api-version=7.1-preview.1"
          $response = Invoke-RestMethod -Uri $url -Method Get -Headers $headers

          # Filter for release/GBIW_x.y pattern
          $pattern = '^refs/heads/release/GBIW_(\d+)\.(\d+)$'
          $matchedBranches = @()

          foreach ($branch in $response.value) {
              if ($branch.name -match $pattern) {
                  $major = [int]$matches[1]
                  $minor = [int]$matches[2]

                  $matchedBranches += [PSCustomObject]@{
                      BranchName = $branch.name
                      Major = $major
                      Minor = $minor
                  }
              }
          }

          # Sort by major and minor version descending
          $latestBranch = $matchedBranches | Sort-Object -Property @{Expression="Major";Descending=$true}, @{Expression="Minor";Descending=$true} | Select-Object -First 1

          # Output result
          if ($latestBranch) {
              Write-Output "Latest release branch matching pattern: $($latestBranch.BranchName)"
              Write-Output "Version: $($latestBranch.Major).$($latestBranch.Minor)"
          } else {
              Write-Output "No branches matched the pattern 'release/GBIW_x.y'"
          }

          Write-Host "##vso[task.setvariable variable=HighestReleaseBranch;isOutput=true]$($latestBranch.BranchName)"
          Write-Host "Detected branch: $branch"
          $url = 'https://feeds.dev.azure.com/StarkNet01/Project%20ForgePoint/_apis/packaging/Feeds/Kent/Packages/476a8c24-5db1-445a-bcaf-9120a9639a03/versions?api-version=6.0-preview.1'
          $PackageInfo = (Invoke-RestMethod -Uri $url -Method Get -UseDefaultCredential -Headers $headers) 
          $LatestVersion= $PackageInfo.value.version | Select-Object -first 1
          Write-Host "Latest package Version =Â $LatestVersion"
          Write-Host "##vso[task.setvariable variable=LatestVersion;isOutput=true]$LatestVersion"
          
      env:
        PAT: $(PAT)
        Organisation: $(Organisation)
        repositoryId: $(repositoryId)
        project: $(Project)

  - job: DeployAPI
    displayName: 'Deploy API'
    dependsOn: DetectBranch
    variables:
      HighestReleaseBranch: $[ dependencies.DetectBranch.outputs['detect.HighestReleaseBranch'] ]
      Latestartifactversion: $[ dependencies.DetectBranch.outputs['detect.LatestVersion'] ]
    pool:
      vmImage: 'windows-latest'

    steps:
    - task: PowerShell@2
      displayName: print the vars
      inputs:
        targetType: inline
        script: |
          Write-Host "highestBranch: $(HighestReleaseBranch)"
          Write-Host "Latestartifactversion: $(Latestartifactversion)"

    - task: UniversalPackages@0
      displayName: 'Download Universal Package'
      inputs:
        command: 'download'
        downloadDirectory: '$(System.ArtifactsDirectory)/api'
        feedsToUse: 'internal'
        vstsFeed: 'c70a2f22-0e6a-457d-a56f-4f6733761244/464ac2eb-4d82-46d9-8069-c43b9594ead2'
        vstsFeedPackage: '476a8c24-5db1-445a-bcaf-9120a9639a03'
        vstsPackageVersion: '$(Latestartifactversion)'

    - task: PowerShell@2
      displayName: 'List contents of downloaded API artifact folder'
      inputs:
        targetType: 'inline'
        script: |
          $path = "$(System.ArtifactsDirectory)/api"
          $path2 ="$(Build.SourcesDirectory)"
          Write-Host "Listing contents of: $path"
          Write-Host "Listing  the branch content: $path2"
          if (Test-Path $path) {
            Get-ChildItem -Path $path -Recurse | ForEach-Object {
              Write-Host "$($_.FullName)"
            }
          } else {
            Write-Error "Path does not exist: $path"
          }
          if (Test-Path $path2) {
            Get-ChildItem -Path $path2 -Recurse | ForEach-Object {
              Write-Host "$($_.FullName)"
            }
          } else {
            Write-Error "Path2 does not exist: $path2"
          }

    # - task: PowerShell@2
    #   displayName: 'Unzip Downloaded Artifact'
    #   inputs:
    #     targetType: 'inline'
    #     script: |
    #       $zipPath = "$(System.ArtifactsDirectory)/api/api.zip"
    #       $dest = "$(Build.SourcesDirectory)/unzipped"
    #       Expand-Archive -Path $zipPath -DestinationPath $dest -Force

    - task: PowerShell@2
      displayName: 'Replace appsettings.json from Branch'
      inputs:
        targetType: 'inline'
        script: |
          $customer = '${{ parameters.Customer }}'
          $safeCustomer = $customer -replace '[^a-zA-Z0-9]', ''
          $sourceFile = "$(Build.SourcesDirectory)/API/ASP.net_core_API/appsettings.$safeCustomer.json"
          $targetFile = "$(System.ArtifactsDirectory)/api/appsettings.json"

          if (Test-Path $sourceFile) {
            Copy-Item -Path $sourceFile -Destination $targetFile -Force
            Write-Host "Replaced appsettings.json with $sourceFile"
          } else {
            Write-Error "Customer-specific file not found: $sourceFile"
            exit 1
          }

    - task: PowerShell@2
      displayName: 'Clean Up Other Config Files'
      inputs:
        targetType: 'inline'
        script: |
          $artifactDir = "$(System.ArtifactsDirectory)/api"
          $zipPath = "$(Build.ArtifactStagingDirectory)/api_rezipped.zip"

          Write-Host "Cleaning up config files in: $artifactDir"

          # Delete all appsettings.*.json except appsettings.json
          Get-ChildItem -Path $artifactDir -Filter "appsettings.*.json" | Where-Object { $_.Name -ne "appsettings.json" } | Remove-Item -Force

          Write-Host "Removed unnecessary appsettings.*.json files."

          # Delete existing zip if present
          if (Test-Path $zipPath) {
            Remove-Item $zipPath -Force
            Write-Host "Removed old zip file: $zipPath"
          }

          # Create new zip of cleaned artifact directory
          Add-Type -AssemblyName 'System.IO.Compression.FileSystem'
          [System.IO.Compression.ZipFile]::CreateFromDirectory($artifactDir, $zipPath)

          Write-Host "Zipped cleaned API folder to: $zipPath"

    - task: PowerShell@2
      name: SetWebApps
      displayName: 'Set Web App Names based on Customer'
      inputs:
        targetType: 'inline'
        script: |
          $customer = '${{ parameters.Customer }}'
          $webApps = @{
            "Kent"         = @{ UI = "kent-ui-webapp"; API = "Apitestres" }
            "CustomerZero" = @{ UI = "cz-ui"; API = "cz-api" }
            "CAM"          = @{ UI = "cam-ui"; API = "cam-api" }
            "GM"           = @{ UI = "gm-ui"; API = "gm-api" }
            "TVS"          = @{ UI = "tvs-ui"; API = "tvs-api" }
            "Banes"        = @{ UI = "banes-ui"; API = "banes-api" }
            "NARP(NCR)"    = @{ UI = "narp-ui"; API = "narp-api" }
            "Staffs(OHC)"  = @{ UI = "staffs-ui"; API = "staffs-api" }
            "Test"         = @{ UI = "test-ui"; API = "test-api" }
          }

          if ($webApps.ContainsKey($customer)) {
            $ui = $webApps[$customer].UI
            $api = $webApps[$customer].API
            Write-Host "##vso[task.setvariable variable=uiWebApp;isOutput=true]$ui"
            Write-Host "##vso[task.setvariable variable=apiWebApp;isOutput=true]$api"
            Write-Host "UiApp: $ui"
            Write-Host "API app: $api"
          } else {
            Write-Error "No web app mapping found for customer: $customer"
            exit 1
          }

    - task: AzureWebApp@1
      displayName: 'Deploy API to WebApp'
      inputs:
        azureSubscription: 'Dotnet'
        appType: 'webApp'
        appName: '$(SetWebApps.apiWebApp)'
        package: '$(Build.ArtifactStagingDirectory)/api_rezipped.zip'
