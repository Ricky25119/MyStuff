trigger:
- none

pool:
  vmImage: 'windows-latest'

variables:
  - group: Orchestration
  - name: apiPipelinePath
    value: 'API/API-Deployment.yml'
  - name: uiPipelinePath
    value: 'UI/UI-Deployment.yml'
  - name: serviceconnection
    value: 'Dotnet'
  - name: APIWebapp
    value: 'Apitestres'
  - name: UIWebapp
    value: 'testres'

stages:

- stage: CustomerExtraction
  displayName: 'Determine the customer'  
  jobs:
    - job: ExtractCustomer
      displayName: 'Get customer spec'
      steps:
        - checkout: self
          persistCredentials: true
          fetchDepth: 0

        - task: PowerShell@2
          name: CustomerName
          displayName: 'Extarct customer and check change type'
          inputs:
            targetType: 'inline'
            script: |
              Write-Host "Starting script..."
              Write-Host "Organisation: $env:Organisation"
              

              $pat = $env:PAT
              $organization = $env:Organisation
              $repositoryId = $env:repositoryId
              $token = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$pat"))
              $headers = @{ Authorization = "Basic $token"  }

              $Baseuri = "https://dev.azure.com/$organization/"
              $targetBranch = "refs/heads/develop"
              $uri = "${Baseuri}_apis/git/repositories/$repositoryId/pullrequests?searchCriteria.status=completed&searchCriteria.targetRefName=$([uri]::EscapeDataString($targetBranch))&api-version=6.1-preview&`$top=100"
              $response = Invoke-RestMethod -Uri $uri -Method Get -Headers $headers

              if ($response.count -eq 0) {
                Write-Host "No completed PRs found."
                exit 1
              } 
              $latestPR = $response.value | Sort-Object closedDate -Descending | Select-Object -First 1
              $prId = $latestPR.pullRequestId
              $title = $latestPR.title
              $description = $latestPR.description
              $PrRaisedTo = $latestPR.targetRefName
              $labelUri = "${Baseuri}_apis/git/repositories/$repositoryId/pullRequests/$prId/labels?api-version=7.1"
              $labelResponse = Invoke-RestMethod -Uri $labelUri -Method Get -Headers $headers
              if (-not $labelResponse.value -or $labelResponse.value.Count -eq 0) {
                Write-Error "No labels (tags) found on the PR. Expected a tag like GBI_3.9.0"
                exit 1
              }
              $tag = $labelResponse.value[0].name
              Write-Host "Found tag: $tag"
              $regex = '^GBI_\d+\.\d+\.\d+(\.\d+)?$'
              if ($tag -notmatch $regex) {
                Write-Error "Tag '$tag' does not match the expected format (e.g., GBI_3.9.0 or GBI_3.3.0.0)."
                exit 1
                }
              Write-Host "Valid tag format: $tag"
              Write-Host "Change Type : $changeType , Config: $buildConfiguration,PR title: $title, PR Description: $description,PR raised to: $PrRaisedTo, Tag Mentioned: $tag  "
              Write-Host "##vso[task.setvariable variable=tag;isOutput=true]$tag"

          env:
            PAT: $(PAT)
            Organisation: $(Organisation)
            repositoryId: $(repositoryId)
        
# Stage: Build and Publish to Azure Artifacts
- stage: BuildAPI
  displayName: 'Build API'
  dependsOn: CustomerExtraction
  condition: succeeded()
  variables:
    tag: $[stageDependencies.CustomerExtraction.ExtractCustomer.outputs['CustomerName.tag']]
  jobs:
  - job: Build
    displayName: 'Build and Package'
    pool:
      vmImage: 'windows-latest'
    steps:
    - task: NuGetToolInstaller@1

    - task: NuGetCommand@2
      inputs:
        restoreSolution: '**/ASP.NET_Core_API.sln'

    - task: VSBuild@1
      inputs:
        solution: '**/ASP.NET_Core_API.sln'
        msbuildArgs: '/p:DeployOnBuild=true'
        platform: 'Any CPU'
        configuration: 'Release'

    - task: DotNetCoreCLI@2
      displayName: 'Publish ASP.NET Core API'
      inputs:
        command: 'publish'
        publishWebProjects: false
        projects: 'API/ASP.net_core_API/*.csproj'
        arguments: '--configuration Release --output $(Build.ArtifactStagingDirectory)'
        zipAfterPublish: false

    - task: UniversalPackages@0
      displayName: 'Publish Universal Package to Azure Artifacts'
      inputs:
        command: 'publish'
        publishDirectory: '$(Build.ArtifactStagingDirectory)'
        feedsToUse: 'internal'
        vstsFeedPublish: 'c70a2f22-0e6a-457d-a56f-4f6733761244/464ac2eb-4d82-46d9-8069-c43b9594ead2'  # Replace this with your feed ID or name
        vstsFeedPackagePublish: 'Workbench'
        versionOption: 'custom'
        versionPublish: '$(tag)'  # Customize versioning if needed

- stage: DeployAPI
  displayName: 'Deploy API'
  dependsOn: BuildAPI
  condition: succeeded()
  variables:
    tag: $[stageDependencies.CustomerExtraction.ExtractCustomer.outputs['CustomerName.tag']]
  jobs:
  - deployment: Deploy
    displayName: 'Deploy to Azure Web App'
    environment: 'Staging'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: UniversalPackages@0
            displayName: 'Download Universal Package'
            inputs:
              command: 'download'
              downloadDirectory: '$(System.ArtifactsDirectory)/api'
              feedsToUse: 'internal'
              vstsFeed: 'c70a2f22-0e6a-457d-a56f-4f6733761244/464ac2eb-4d82-46d9-8069-c43b9594ead2'
              vstsFeedPackage: 'Workbench'
              vstsPackageVersion: '$(tag)'  # Same as used during publish

          - task: ArchiveFiles@2
            inputs:
              rootFolderOrFile: '$(System.ArtifactsDirectory)/api'
              includeRootFolder: false
              archiveType: 'zip'
              archiveFile: '$(System.ArtifactsDirectory)/api.zip'
              replaceExistingArchive: true

          - task: AzureRmWebAppDeployment@5
            displayName: 'Deploy to Azure Web App'
            inputs:
              ConnectionType: 'AzureRM'
              azureSubscription: '$(serviceconnection)'
              appType: 'webApp'
              WebAppName: '$(APIWebapp)'
              packageForLinux: '$(System.ArtifactsDirectory)/api.zip'



# - stage: BuildUI
#   displayName: 'Build UI'
#   variables:
#     buildConfiguration: $[stageDependencies.CustomerExtraction.ExtractCustomer.outputs['CustomerName.buildConfiguration']]
#   dependsOn: DeployStagingProductionAPI
#   jobs:
#   - job: Build
#     pool:
#       vmImage: 'windows-latest'
#     steps:
#     - task: NuGetToolInstaller@1
#     - task: NuGetCommand@2
#       inputs:
#         restoreSolution: '**/ASP_dotnet.sln'
#     - task: VSBuild@1
#       inputs:
#         solution: '**/ASP_dotnet.sln'
#         msbuildArgs: '/p:DeployOnBuild=true /p:WebPublishMethod=Package /p:PackageAsSingleFile=true /p:SkipInvalidConfigurations=true /p:PackageLocation="$(Build.ArtifactStagingDirectory)"'
#         platform: 'Any CPU'
#         configuration: '$(buildConfiguration)'    
#     - task: Bash@3
#       displayName: 'Get short SHA'
#       inputs:
#         targetType: 'inline'
#         script: |
#           SHORT_SHA=$(echo $(Build.SourceVersion) | cut -c1-7)
#           echo "##vso[task.setvariable variable=shortSha]$SHORT_SHA"
#           echo "SHORT_SHA: $SHORT_SHA"
#     - task: PublishBuildArtifacts@1
#       inputs:
#         PathtoPublish: '$(Build.ArtifactStagingDirectory)'
#         ArtifactName: 'Webapp'
#         publishLocation: 'Container'
#   # Tag build with short SHA
#     - task: Bash@3
#       displayName: 'Tag build with short SHA'
#       inputs:
#         targetType: 'inline'
#         script: |
#           SHORT_SHA=$(echo $(Build.SourceVersion) | cut -c1-7)
#           echo "Triggering build for short SHA: $SHORT_SHA"
#           echo "##vso[build.addbuildtag]shortsha-$SHORT_SHA"

# # Stage 3: Deploy to Staging and Production
# - stage: DeployStagingProductionUI
#   displayName: 'Deploy Dev UI'
#   dependsOn: BuildUI
#   condition: succeeded()
#   jobs:
#     - deployment: DeployStaging
#       displayName: 'Deploy to Staging Slot'
#       environment: 'Staging'
#       strategy:
#         runOnce:
#           deploy:
#             steps:
#               - task: DownloadBuildArtifacts@1
#                 inputs:
#                   buildType: 'current'
#                   downloadType: 'single'
#                   artifactName: 'Webapp'
#                   tags: 'shortsha-$(shortSha)'
#                   downloadPath: '$(System.ArtifactsDirectory)'
#                 displayName: 'Download Artifacts'

#               - task: PowerShell@2
#                 displayName: 'Consumed Artifact '
#                 inputs:
#                   targetType: 'inline'
#                   script: |
#                     Write-Host "Downloaded artifact from build triggered by the current merge."
#                     Write-Host "Contents of $(System.ArtifactsDirectory):"
#                     Get-ChildItem -Recurse -Force "$(System.ArtifactsDirectory)"

#               - task: AzureRmWebAppDeployment@5
#                 inputs:
#                   ConnectionType: 'AzureRM'
#                   azureSubscription: '$(serviceconnection)'
#                   appType: 'webApp'
#                   WebAppName: '$(UIWebapp)'
#                   packageForLinux: '$(System.ArtifactsDirectory)/Webapp/**/*.zip'
#                 displayName: 'Deploy to Staging Slot'

- stage: ReleaseVersioning
  displayName: 'Create Release Branch'
  dependsOn: DeployStagingProductionAPI
  condition: succeeded()
  jobs:
  - deployment: CreateRelease
    displayName: 'Create Release Branch'
    environment: 'Staging'   
    strategy:
      runOnce:
        deploy:
          steps:
            - checkout: self
              persistCredentials: true
              fetchDepth: 0

            - task: PowerShell@2
              name: CreateReleaseBranch
              displayName: 'Create release branch'
              inputs:
                targetType: 'inline'
                script: |
                  Write-Host "Starting script..."
                  Write-Host "Organisation: $env:Organisation"
                  $pat = $env:PAT
                  $organization = $env:Organisation
                  $repositoryId = $env:repositoryId
                  $token = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$pat"))
                  $headers = @{ Authorization = "Basic $token"  }
                  $Baseuri = "https://dev.azure.com/$organization/"
                  $targetBranch = "refs/heads/develop"
                  $uri = "${Baseuri}_apis/git/repositories/$repositoryId/pullrequests?searchCriteria.status=completed&searchCriteria.targetRefName=$([uri]::EscapeDataString($targetBranch))&api-version=6.1-preview&`$top=100"
                  $response = Invoke-RestMethod -Uri $uri -Method Get -Headers $headers
                  if ($response.count -eq 0) {
                    Write-Host "No completed PRs found. Defaulting to 'minor'."
                    $changeType = "minor"
                    $buildConfiguration = "Release"
                  } else {
                    $latestPR = $response.value | Sort-Object closedDate -Descending | Select-Object -First 1
                    $title = $latestPR.title
                    $description = $latestPR.description
                    $PrRaisedTo = $latestPR.targetRefName
                    if ($description -match "(?i)buildConfiguration\s*=\s*'([^']+)'") {
                        $buildConfiguration = $matches[1]
                    } else {
                        $buildConfiguration = "Release"
                    }
                  Write-Host "Customer Name: $buildConfiguration"
                  if ($title -match '(?i)\bmajor\b') {
                      $changeType = "major"
                    } else {
                      $changeType = "minor"
                    }
                  }
                  Write-Host "Determined CHANGE_TYPE: $changeType"
                  git fetch --all
                  $branches = git branch -r | Where-Object { $_ -match 'origin/Release/\d+\.\d+-rc$' } | ForEach-Object {
                      ($_ -replace 'origin/Release/', '') -replace '-rc.*$', ''
                  }
                  if (-not $branches) {
                      $major = 1
                      $minor = 0
                  } else {
                      $latest = $branches | Sort-Object { [version]$_ } | Select-Object -Last 1
                      Write-Host "Latest version found: $latest"
                      $parts = $latest -split '\.'
                      $major = [int]$parts[0]
                      $minor = [int]$parts[1]
                      if ($changeType -eq "major") {
                          $major++
                          $minor = 0
                      } else {
                          $minor++
                      }
                  }
                  $version = "$major.$minor-rc-$buildConfiguration"
                  $tag = "v$version"
                  $branchName = "Release/$version"
                  $tagName = "v$version"
                  Write-Host "Creating branch: $branchName"
                  git checkout -b $branchName
                  git push origin $branchName
                  Write-Host "Creating tag: $tagName"
                  git tag $tagName
                  git push origin $tagName
                  Write-Host "##vso[task.setvariable variable=releaseBranch;isOutput=true]$branchName"
                  Write-Host "##vso[task.setvariable variable=releaseTag;isOutput=true]$tag"
                  Write-Host "##vso[task.setvariable variable=version;isOutput=true]$version"
              env:
                PAT: $(PAT)
                Organisation: $(Organisation)
                repositoryId: $(repositoryId)
                CustomerName: $(customerName)

            - task: DownloadBuildArtifacts@1
              inputs:
                buildType: 'current'
                downloadType: 'single'
                artifactName: 'drop'
                downloadPath: '$(System.ArtifactsDirectory)'
            - task: UniversalPackages@0
              displayName: 'Publish artifact to Azure Artifacts'
              inputs:
                command: 'publish'
                publishDirectory: '$(System.ArtifactsDirectory)/drop'
                feedsToUsePublish: 'internal'
                vstsFeedPublish: 'c70a2f22-0e6a-457d-a56f-4f6733761244/464ac2eb-4d82-46d9-8069-c43b9594ead2'
                vstsFeedPackagePublish: 'Workbench'
                versionOption: 'custom'
                versionPublish: '$(version)'

